# -*- coding: utf-8 -*-
"""making_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EOopVa4AF48Im7Ma-GwWmZ3fgZ0vPw-X
"""

import os
import numpy as np
import time
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
from torch.utils.data import Dataset
import chess
from chess import pgn
from tqdm import tqdm
from chess import Board
import pickle

def board_to_matrix(board: Board):
    # 8x8 is a size of the chess board.
    # 12 = number of unique pieces.
    # 13th board for legal moves (WHERE we can move)
    # maybe 14th for squares FROM WHICH we can move? idk
    matrix = np.zeros((13, 8, 8))
    piece_map = board.piece_map()

    # Populate first 12 8x8 boards (where pieces are)
    for square, piece in piece_map.items():
        row, col = divmod(square, 8)
        piece_type = piece.piece_type - 1
        piece_color = 0 if piece.color else 6
        matrix[piece_type + piece_color, row, col] = 1

    # Populate the legal moves board (13th 8x8 board)
    legal_moves = board.legal_moves
    for move in legal_moves:
        to_square = move.to_square
        row_to, col_to = divmod(to_square, 8)
        matrix[12, row_to, col_to] = 1

    return matrix

class ChessModel(nn.Module):
    def __init__(self, num_classes):
        super(ChessModel, self).__init__()
        # conv1 -> relu -> conv2 -> relu -> flatten -> fc1 -> relu -> fc2
        self.conv1 = nn.Conv2d(13, 64, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(64, 128, kernel_size=3, padding=1)
        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(8 * 8 * 128, 256)
        self.fc2 = nn.Linear(256, num_classes)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.relu(self.conv2(x))
        x = self.flatten(x)
        x = self.relu(self.fc1(x))
        x = self.fc2(x)  # Output raw logits
        return x

def prepare_input(board: Board):
    matrix = board_to_matrix(board)
    X_tensor = torch.tensor(matrix, dtype=torch.float32).unsqueeze(0)
    return X_tensor

with open("movetointegers", "rb") as file:
    move_to_int = pickle.load(file)

# Check for GPU
#device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
#print(f'Using device: {device}')

# Load the model
model = ChessModel(num_classes=len(move_to_int))
model.load_state_dict(torch.load("ChessCNN.pth", map_location=torch.device('cpu')))
#model.to(device)
model.eval()  # Set the model to evaluation mode (it may be reductant)

int_to_move = {v: k for k, v in move_to_int.items()}
# Function to make predictions
def predict_move(board: Board):
    X_tensor = prepare_input(board)

    with torch.no_grad():
        logits = model(X_tensor)

    logits = logits.squeeze(0)  # Remove batch dimension

    probabilities = torch.softmax(logits, dim=0).numpy()  # Convert to probabilities
    legal_moves = list(board.legal_moves)
    legal_moves_uci = [move.uci() for move in legal_moves]
    sorted_indices = np.argsort(probabilities)[::-1]
    for move_index in sorted_indices:
        move = int_to_move[move_index]
        if move in legal_moves_uci:
            return move

    return None

def evaluate_position(board):
    # Define a simple evaluation function, for example, based on material balance.
    # More advanced evaluations could factor in piece positioning, king safety, etc.
    return sum(piece_value(piece) for piece in board.piece_map().values())

def piece_value(piece):
    # Define values for each piece type
    values = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9, chess.KING: 0}
    return values[piece.piece_type] if piece.color == chess.WHITE else -values[piece.piece_type]

    return score

def predict_top_moves(board, top_n=5):
    X_tensor = prepare_input(board)

    with torch.no_grad():
        logits = model(X_tensor)

    logits = logits.squeeze(0)
    probabilities = torch.softmax(logits, dim=0).numpy()  # Convert logits to probabilities

    legal_moves = list(board.legal_moves)
    legal_moves_uci = [move.uci() for move in legal_moves]
    sorted_indices = np.argsort(probabilities)[::-1]

    # Collect top moves that are legal
    top_moves = []
    for move_index in sorted_indices:
        move = int_to_move[move_index]
        if move in legal_moves_uci:
            top_moves.append(chess.Move.from_uci(move))
            if len(top_moves) >= top_n:
                break
    return top_moves

def minimax_with_ordering(board, depth, is_maximizing, alpha, beta, top_n=5):
    if depth == 0 or board.is_game_over():
        return evaluate_position(board)  # Returns evaluation score

    # Get top moves from model predictions
    top_moves = predict_top_moves(board, top_n=top_n)

    if is_maximizing:
        max_eval = -float('inf')
        for move in top_moves:
            board.push(move)
            eval = minimax_with_ordering(board, depth - 1, False, alpha, beta, top_n)
            board.pop()
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break  # Beta cutoff
        return max_eval
    else:
        min_eval = float('inf')
        for move in top_moves:
            board.push(move)
            eval = minimax_with_ordering(board, depth - 1, True, alpha, beta, top_n)
            board.pop()
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break  # Alpha cutoff
        return min_eval

def find_best_move(board, depth=3, top_n=5):
    best_move = None
    best_eval = -float('inf')
    alpha = -float('inf')
    beta = float('inf')

    top_moves = predict_top_moves(board, top_n=top_n)

    for move in top_moves:
        board.push(move)
        eval = minimax_with_ordering(board, depth - 1, is_maximizing=False, alpha=alpha, beta=beta, top_n=top_n)
        board.pop()

        if eval > best_eval:
            best_eval = eval
            best_move = move

    return best_move.uci() if best_move else None

import chess

# Initialize the board
board = chess.Board()

# Parameters
#depth = 3  # Depth for Minimax search
#top_n = 5  # Number of top moves to consider in Minimax

def play_game(board, depth, top_n=5):
    while not board.is_game_over():
        print("\nCurrent board:\n", board)

        # Minimax AI's turn (let's assume Minimax plays as White)
        if board.turn == chess.WHITE:
            best_move = find_best_move(board, depth=depth, top_n=top_n)
            if best_move is None:
                print("Minimax AI (White) resigns!")
                break
            print("Minimax AI (White) plays:", best_move)
            board.push_uci(best_move)

        # Model AI's turn (let's assume Model AI plays as Black)
        else:
            model_move = predict_move(board)
            if model_move is None:
                print("Model AI (Black) resigns!")
                break
            print("Model AI (Black) plays:", model_move)
            board.push_uci(model_move)

    # Print game result
    print("\nGame Over")
    print("Result:", board.result())

def play_game2(board, depth, top_n=5):
    while not board.is_game_over():
        print("\nCurrent board:\n", board)

        # Minimax AI's turn (let's assume Minimax plays as White)
        if board.turn == chess.WHITE:
            model_move = predict_move(board)
            if model_move is None:
                print("Model AI (white) resigns!")
                break
            print("Model AI (white) plays:", model_move)
            board.push_uci(model_move)


        # Model AI's turn (let's assume Model AI plays as Black)
        else:
            best_move = find_best_move(board, depth=depth, top_n=top_n)
            if best_move is None:
                print("Minimax AI (black) resigns!")
                break
            print("Minimax AI (black) plays:", best_move)
            board.push_uci(best_move)


    # Print game result
    print("\nGame Over")
    print("Result:", board.result())

play_game2(board, depth=5, top_n=5)

