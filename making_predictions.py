# -*- coding: utf-8 -*-
"""making_predictions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18t7tgB_PBt6EpEsXgS1ySNp6HO9EOg2z
"""

import os
import numpy as np
import time
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader
from torch.utils.data import Dataset
import chess
from chess import pgn
from tqdm import tqdm
from chess import Board
import pickle

def board_to_matrix(board: Board):
    # 8x8 is a size of the chess board.
    # 12 = number of unique pieces.
    # 13th board for legal moves (WHERE we can move)
    # maybe 14th for squares FROM WHICH we can move? idk
    matrix = np.zeros((13, 8, 8))
    piece_map = board.piece_map()

    # Populate first 12 8x8 boards (where pieces are)
    for square, piece in piece_map.items():
        row, col = divmod(square, 8)
        piece_type = piece.piece_type - 1
        piece_color = 0 if piece.color else 6
        matrix[piece_type + piece_color, row, col] = 1

    # Populate the legal moves board (13th 8x8 board)
    legal_moves = board.legal_moves
    for move in legal_moves:
        to_square = move.to_square
        row_to, col_to = divmod(to_square, 8)
        matrix[12, row_to, col_to] = 1

    return matrix

class ChessModel(nn.Module):
    def __init__(self, num_classes):
        super(ChessModel, self).__init__()
        # conv1 -> relu -> conv2 -> relu -> flatten -> fc1 -> relu -> fc2
        self.conv1 = nn.Conv2d(13, 64, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(64, 128, kernel_size=3, padding=1)
        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(8 * 8 * 128, 256)
        self.fc2 = nn.Linear(256, num_classes)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.relu(self.conv2(x))
        x = self.flatten(x)
        x = self.relu(self.fc1(x))
        x = self.fc2(x)  # Output raw logits
        return x

def prepare_input(board: Board):
    matrix = board_to_matrix(board)
    X_tensor = torch.tensor(matrix, dtype=torch.float32).unsqueeze(0)
    return X_tensor

with open("movetointegers", "rb") as file:
    move_to_int = pickle.load(file)

# Check for GPU
#device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
#print(f'Using device: {device}')

# Load the model
model = ChessModel(num_classes=len(move_to_int))
model.load_state_dict(torch.load("ChessCNN.pth", map_location=torch.device('cpu')))
#model.to(device)
model.eval()  # Set the model to evaluation mode (it may be reductant)

int_to_move = {v: k for k, v in move_to_int.items()}
# Function to make predictions
def predict_move(board: Board):
    X_tensor = prepare_input(board)

    with torch.no_grad():
        logits = model(X_tensor)

    logits = logits.squeeze(0)  # Remove batch dimension

    probabilities = torch.softmax(logits, dim=0).numpy()  # Convert to probabilities
    legal_moves = list(board.legal_moves)
    legal_moves_uci = [move.uci() for move in legal_moves]
    sorted_indices = np.argsort(probabilities)[::-1]
    for move_index in sorted_indices:
        move = int_to_move[move_index]
        if move in legal_moves_uci:
            return move

    return None

def evaluate_position(board):
    """
    Evaluates the current board position.
    Considers material balance, king safety, mobility, and optional model predictions.
    """
    score = 0

    # Material balance
    for piece in board.piece_map().values():
        piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}
        score += piece_value.get(piece.piece_type, 0) if piece.color == chess.WHITE else -piece_value.get(piece.piece_type, 0)

    # Mobility (number of legal moves available)
    legal_moves = list(board.legal_moves)
    mobility_score = len(legal_moves) * 0.1  # Encourage positions with more mobility
    score += mobility_score if board.turn == chess.WHITE else -mobility_score

    # King safety (reduce score if the king is in check)
    if board.is_check():
        score -= 15 if board.turn == chess.WHITE else -15

    # Evaluate special moves
    for move in legal_moves:
        if board.is_capture(move):
            captured_piece = board.piece_at(move.to_square)
            if captured_piece:
                piece_value = {chess.PAWN: 1, chess.KNIGHT: 3, chess.BISHOP: 3, chess.ROOK: 5, chess.QUEEN: 9}
                score += piece_value.get(captured_piece.piece_type, 0) if board.turn == chess.WHITE else -piece_value.get(captured_piece.piece_type, 0)
        elif board.is_en_passant(move):  # En passant
            score += 1 if board.turn == chess.WHITE else -1
        elif move.promotion:  # Pawn promotion
            promoted_piece_value = {chess.QUEEN: 9, chess.ROOK: 5, chess.BISHOP: 3, chess.KNIGHT: 3}
            score += promoted_piece_value.get(move.promotion, 0) if board.turn == chess.WHITE else -promoted_piece_value.get(move.promotion, 0)
        elif board.is_castling(move):  # Castling
            score += 5 if board.turn == chess.WHITE else -5

    return score

def predict_top_moves(board, top_n=5):
    X_tensor = prepare_input(board)

    with torch.no_grad():
        logits = model(X_tensor)

    logits = logits.squeeze(0)
    probabilities = torch.softmax(logits, dim=0).numpy()  # Convert logits to probabilities

    legal_moves = list(board.legal_moves)
    legal_moves_uci = [move.uci() for move in legal_moves]
    sorted_indices = np.argsort(probabilities)[::-1]

    # Collect top moves that are legal
    top_moves = []
    for move_index in sorted_indices:
        move = int_to_move[move_index]
        if move in legal_moves_uci:
            top_moves.append(chess.Move.from_uci(move))
            if len(top_moves) >= top_n:
                break
    return top_moves

def minimax_with_ordering(board, depth, is_maximizing, alpha, beta, top_n=5):
    if depth == 0 or board.is_game_over():
        return evaluate_position(board)  # Returns evaluation score

    # Get top moves from model predictions
    top_moves = predict_top_moves(board, top_n=top_n)

    if is_maximizing:
        max_eval = -float('inf')
        for move in top_moves:
            board.push(move)
            eval = minimax_with_ordering(board, depth - 1, False, alpha, beta, top_n)
            board.pop()
            max_eval = max(max_eval, eval)
            alpha = max(alpha, eval)
            if beta <= alpha:
                break  # Beta cutoff
        return max_eval
    else:
        min_eval = float('inf')
        for move in top_moves:
            board.push(move)
            eval = minimax_with_ordering(board, depth - 1, True, alpha, beta, top_n)
            board.pop()
            min_eval = min(min_eval, eval)
            beta = min(beta, eval)
            if beta <= alpha:
                break  # Alpha cutoff
        return min_eval

def find_best_move(board, depth=5):
    """
    Determines the best move using Minimax with move ordering.
    Dynamically adjusts top_n based on the player's color.
    """
    best_move = None
    best_eval = -float('inf')
    alpha = -float('inf')
    beta = float('inf')

    # Dynamically set top_n based on the current player's color
    top_n = 1 if board.turn == chess.BLACK else 5

    # Get the top moves based on the model's predictions
    top_moves = predict_top_moves(board, top_n=top_n)

    for move in top_moves:
        # Simulate the move
        board.push(move)

        # Evaluate the move using Minimax
        eval = minimax_with_ordering(board, depth - 1, is_maximizing=False, alpha=alpha, beta=beta, top_n=top_n)

        # Undo the move
        board.pop()

        # Track the best move
        if eval > best_eval:
            best_eval = eval
            best_move = move

    return best_move.uci() if best_move else None

